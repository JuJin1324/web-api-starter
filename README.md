# web-api-starter

## API / SDK
### API
> Application Programing Interface: 커뮤니케이션에 관한 정의로 다른 앱, 서비스와의 통신을 위한 정의와 프로토콜이 있다.
> 
> **특징**  
> 추상화(Abstraction) : 프로세스를 단순화, 복잠한 논리를 다 생각할 필요 없음  
> 표준화 : 정의하는 업계 표준이 있음 (ex. SOAP, GraphQL, REST)  
> 
> **예시**  
> 페이스북 공유하기 기능을 제공하는 API를 티스토리 블로그 페이지에서 사용할 수 있도록 연동하는 식입니다. 
> 이때 공유하기라는 이미 만들어진 기능을 가져다 쓰는 한편, 해당 버튼을 눌렀을 때 페이스북 서버와 통신을 하게 됩니다.

### SDK
> Software Development Kit: 디버거, 프레임워크 등 특정 플랫폼을 위한 소프트웨어 빌딩툴 또는 특정 OS의 코드 라이브러리 그룹 같은 개발도구의 집합이다. 
> ex) 안드로이드, iOS SDK등등  
> 
> 실제로 api를 호출해주는 메소드를포함 → api request 를 직접 쓸 필요가 없음.  
> response또한 json 같은 형태일 필요가 없음 → analyze response object 로 받을 수 있음.
> 
> **예시**  
> 페이스북 좋아요 기능에 대한 API와 SDK가 있다면, API는 "좋아요 기능을 만들어 놨으니까 연동해서 사용하세요"인 반면 
> SDK는 "좋아요 기능을 만들기 위해 필요한 재료를 드릴 테니까 원하는 대로 만들어보세요"인 것이죠.   
> SDK는 특정 목적을 가진 개발에 필요한 모듈, 샘플 소스, 매뉴얼 등이 포함된다는 점에서 반드시 필요하다고 볼 수 있습니다.  

### SDK와 API의 차이점
> API : 결과를 받아오기 위해 어떤 작업을 수행해야 하는지 알려줄 뿐 받아온 이후의 처리는 개발자의 몫  
> SDK : 소프트웨어 개발을 위한 실제 코드까지 있음  
> 결국 SDK 가 조금 더 크고 편한 도구라고 할 수 있다. (하지만 API가 더 결과를 내맘대로 가공할 수 있는경우도 있을 것이다.)  

### 참조사이트
> [API, SDK(JDK, ADK) 차이](https://change-words.tistory.com/entry/API-SDK-차이)  
> [SDK와 API가 뭐가 달라?](https://velog.io/@hacha2011/SDK와-API가-뭐가-달라)   

---

## Stateless Token 을 통한 인증
### JWT
> **특징**  
> JWT는 Claim 기반이라는 방식을 사용하는데, Claim은 사용자에 대한 프로퍼티나 속성을 말한다.
>
> **장점**  
> 1.이 토큰을 이용해서 요청을 받는 서버나 서비스 입장에서는 이 서비스를 호출한 사용자에 대한 추가 정보는 이미 토큰 안에 다 들어가 있기 때문에, 다른 곳에서 가져올 필요가 없다는 장점이 있다.  
> 2.토큰을 생성하는 단계에서는 생성된 토큰을 별도로 서버에서 유지할 필요가 없으며,
> 토큰을 사용하는 API 서버 입장에서는 API 요청을 검증하기 위해서 토큰을 가지고 사용자 정보를 별도로 계정 시스템 등에서 조회할 필요가 없다는 것이다.  
> 3.Claim 기반의 토큰은 토큰 자체가 정보를 담음으로써 토큰으로 서비스나 API 접근을 제어할 때, 별도의 작업이 서버에서 필요하지 않으며,
> 토큰 자체를 서버에서 관리할 필요가 없어서 구현이 상대적으로 단순해진다.
>
> **단점**  
> 한번 발급된 토큰은 값을 수정하거나 폐기가 불가 : JWT는 토큰 내에 모든 정보를 다 가지고 있기 때문에 한 번 발급된 토큰에 대한 변경은 서버에서는
> 더는 불가능하다. 예를 들어서, 토큰을 잘못 발행해서 삭제하고 싶더라도 서명만 맞으면 맞는 토큰으로 인식하기 때문에 서버에서는 한번 발급된 토큰의 정보를 바꾸는 일이 불가능하다.

### Access token
> access token 은 사용자가 서버에 로그인(인증) 시 발급하는 token 이다.  
> 클라이언트에서는 access token 을 로컬에 저장하여 API 호출 시 사용한다.  
> JWT(JSON Web Token)의 단점은, 한 번 발급된 경우 유효기간이 지날 때까지 계속 사용할 수 있기 때문에 만약 토큰이 악의적으로 활용될 경우
> access token의 유효기간이 다 될 때까지 정보가 계속 털릴 수 있다.
> 그리고 이러한 JWT의 문제점을, access token의 유효기간을 줄이고, refresh token이라는 새로운 토큰을 발급함으로써 해결할 수 있다.

### Refresh token
> JWT 의 단점으로 인하여 access token 이 제 3자에게 탈취당할 경우 유효기간이 끝날 때 까지 계속 정보가 털릴 수가 있기 때문에
> access token 의 유효기간을 길게 가져가선 안된다. 하지만 그렇다고 보안을 위해서 유효기간을 너무 짧게 가져가자니 그만큼 사용자가 로그인을 자주 해서
> token 을 다시 발급받아야 하므로 여간 불편하고 귀찮은 일이 아닐 수 없다. access token 의 짧은 유효기간으로 인한 단점을 보완하기 위해 등장한 것이
> refresh token 이다.
>
> **형태**  
> refresh token 을 JWT 로 구현할 수도 있고 UUID 로 구현할 수도 있다. 각각의 특징은 다음과 같다.  
> refresh token 을 JWT 로 구현할 경우 토큰 자체에 데이터를 담을 수 있으며, token 의 유효성을 검증하기 위해 DB 에 엑세스할 필요가 없다.
> 따라서 서버의 부하가 상대적으로 적다.  
> 하지만 access token 과 마찬가지로 refresh token 을 서버에서 제어할 수 없다. 즉 refresh token 을 탈취당했을 때 해당 token 을 무효화 시킬 방법이 없다.
>
> refresh token 을 UUID 혹은 random string 으로 구현할 경우 그 토큰을 사용자와 맵핑 되도록 DB 저장해야한다.
> 이런 경우 refresh token 유효성 검증시 DB 에 엑세스가 필요하다. 하지만 비정상 동작이 의심되는 사용자를 강제로 로그아웃 시키거나 차단이 가능해진다.
> 또한 refresh token 탈취 시 해당 token 을 즉시 무효화 시킬 수 있다(이는 JWT 를 사용한 refresh token 에서는 불가능하다).
>
> **한계**  
> refresh token 으로 인하여 access token 의 유효기간을 짧게 가져갈 수 있지만, 탈취된 access token 이 유효한 그 짧은 시간 동안에 악용되는 것을 막을 수는 없다.  
> 또한 refresh token 을 탈취 당한 경우 마음껏 access token 을 발행할 수 있기 때문에 refresh token 을 탈취당하는 것은 access token 을 탈취당하는 것과
> 동일하다고 봐야한다.  
> 다만 refresh token 을 DB 에 저장할 시에는 access token 과 다르게 서버에서 즉시 무효화를 할 수 있다는 점이 있다.  
> 클라이언트에 저장하는 순간부터 access token 및 refresh token 모두 탈취가능성이 생긴다.
> 따라서 클라이언트는 refresh token 이 탈취되지 않도록 안전하게 보관해야한다.
>
> **의견**  
> 사견으로는 refresh token 을 DB 에 저장하지 않고 JWT 로 관리하는 것은 그저 access token 을 하나 더 만드는 것이라고 생각한다.
> refresh token 의 용도는 access token 의 보조 역할이며 필요에 따라서는 서버에서 무효화를 할 수 있어야 access token 을 보완할 수 있다고 생각든다.

### 참조사이트
> [rest-api-보안-및-인증-방식](https://dongwooklee96.github.io/post/2021/03/28/rest-api-%EB%B3%B4%EC%95%88-%EB%B0%8F-%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EC%8B%9D.html)
> [Access Token의 문제점과 Refresh Token](https://hudi.blog/refresh-token/)

---

## Json Web Token(JWT)
### 개요
> JWT 는 유저를 인증하고 식별하기 위한 토큰(Token)기반 인증이다. RFC 7519 에 자세한 명세가 나와있다.  
> JWT 를 사용하면 RESTful 과 같은 무상태(Stateless)인 환경에서 사용자 데이터를 주고 받을 수 있게된다.  
> JWT는 Header, Payload, Signature 로 구성된다. 또한 각 요소는 . 으로 구분된다.  

### Header
> JWT 에서 사용할 타입과 해시 알고리즘 종류가 담겨있다.   
> 타입은 "JWT" 로 고정이다.  
> 알고리즘은 보통 "HS256" 혹은 "RSA" 가 사용된다.  

### Payload
> 서버에서 첨부한 사용자 권한 정보 및 데이터가 담겨있다.   
> 데이터는 Claims 에 저장한다. 

### Signature
> 개인키로 서명한 전자서명이 담겨있다. 
> 비대칭키를 통해서 개인키로 서명하게 되면 공개키를 통해 검증을 거치게 된다. 
> 서명은 헤더의 인코딩값과, 정보의 인코딩값을 합친후 주어진 비밀키로 해쉬를 하여 생성합니다.

### Claims
> **등록된 클레임(Reserved claims)**  
> 이미 예약된 Claim으로 필수는 아니지만 사용하길 권장된다.  
> `iss`: 발급자(issuer)  
> `sub`: 제목(subject)  
> `aud`: 대상자(audience)  
> `exp`: 만료시간(expiration), 밀리초 형식  
> `iat`: 발급시간(issued at), 밀리초 형식    
> `jti`: 고유 식별자, 중복처리 방지를 위해 사용되며 일회용 토큰에 사용하면 유용.  
> `nbf`: Not Before. 활성 날짜. 현재 시간이 nbf 로 지정한 시간을 지나지 않으면 유효하지 않음을 설정, 밀리초 형식    
> 
> **공개 클레임(Public claims)**  
> 공개 클레임들은 충돌이 방지된 (collision-resistant) 이름을 가지고 있어야 한다. 
> 충돌을 방지하기 위해서는, 클레임 이름을 URI 형식으로 짓는다.  
> ex: `{ "https://velopert.com/jwt_claims/is_admin": true }`  
> 
> **비공개 클레임(Private claims)**  
> 등록된 클레임도아니고, 공개된 클레임들도 아니다. 
> 양 측간에 (보통 클라이언트 <->서버) 협의하에 사용되는 클레임 이름들이다. 
> 공개 클레임과는 달리 이름이 중복되어 충돌이 될 수 있으니 사용할 때에 유의해야합니다.

### 참조사이트
> [JWT(JSON Web Token)의 개념부터 구현까지 알아보기](https://pronist.dev/143)  
> [JWT(JSON Web Token) - 김종근](https://velog.io/@sproutt/JWTJSON-Web-Token-%EA%B9%80%EC%A2%85%EA%B7%BC)  
> [[JWT] JSON Web Token 소개 및 구조](https://velopert.com/2389)  

---

## CORS
### Cross-Origin Resource Sharing
> 교차 출처 리소스 공유  
> Cross 는 다른 출처라고 해석한다.  
> Origin 은 출처를 의미하며 출처란 protocol(https/http), host(www.google.com 등), port(443, 80 등) 을 합친 것이다.  
> 출처를 비교하는 로직은 서버에 구현되어 있는 것이 아닌 웹 브라우저(클라이언트)에 구현되어 있는 스펙이다.  

### SOP  
> Same-Origin Policy 는 말 그대로 같은 출처에서만 리소스를 공유할 수 있다는 규칙을 가진 정책이다.

### CORS 동작
> 브라우저는 요청 헤더에 `Origin` 이라는 필드에 요청을 보내는 출처를 함께 담아보낸다.  
> 이후 서버가 이 요청에 대한 응답을 할 때 응답 헤더의 `Access-Control-Allow-Origin` 이라는 값에 "이 리소스를 접근하는 것이 허용된 출처"를 내려주고,
> 이후 응답을 받은 브라우저는 자신이 보냈던 요청의 Origin 과 서버가 보내준 응답의 Access-Control-Allow-Origin 을 비교해본 후 이 응답이 유효한 응답인지 아닌지를 결정한다. 

### 서버 셋팅
> 서버에서는 `Access-Control-Allow-Origin` 의 값을 설정한다.  
> 만약 서버가 모든 사용자에게 오픈된 API 를 제공하는 경우 `Access-Control-Allow-Origin` 의 값은 `*` 로 모든 출처를 허용하는 와일드카드를 설정한다.  
> 만약 서버가 특정 도메인에서만 사용되는 API 인 경우 `Access-Control-Allow-Origin` 의 값은 특정 도메인과 와일드카드(*)를 적절히 섞어서 설정한다.  
> [확인이 필요함] 안드로이드의 경우 웹 앱을 통한 서버 호출인 경우가 아니라면 CORS 를 확인하지 않기 때문에 CORS 설정이 무의미할 수 있다.       

---

## TPS(처리량) 와 응답시간
> 정보시스템의 대표적인 성능 지표는 처리량 (Throughput)과 응답시간 (Response Time)이다.

### 처리량
> 처리량은 시스템 측면의 대상 시스템에 대한 성능을 평가하는 KPI이며, 단위로는 주로 TPS (Transactions per Second)를 사용한다.
> 이는, 단위 시간당 대상 시스템에서 처리되고 있는 요청 건수를 의미하며, 일반적으로 처리량을 일컬을 때 각 대상 리소스별로 호칭하는 용어가 별도로 존재한다.  
> 처리량 단위  
> CPU : MIPS, MFLOPS  
> Network : BPS, pps  
> Server : tpmC  
> C/S, TP-Monitor, Mainframe : TPS  
> Storage : IOPS  
> 
> TPS (Transactions per Second)  
> 초당 발생하는 Business Transactions  
> TPS = 총 Business Transaction 처리건수 / 단위시간 (sec)  
> 1TPS = 60 TPM = 3600 TPH  
> 시스템의 주요 성능 Factor  

### 응답시간
> 응답시간은 사용자 측면에서의 성능을 평가하는 KPI로 주로 사용되며, 사용자가 해당 업무를 요청한 시점부터 서버로부터 
> 그 결과에 대한 응답을 받아서 사용자 화면에 디스플레이할 때까지 소요된 총시간이다.  
> 그러므로 다음과 같이 각 리소스별로 소요된 시간의 합으로 나타낼 수 있다.  
> ```
> Response Time = Client Time + Network Time + Server Processing/Sending Time
> ```
> 응답시간을 소요시간으로 구분하면, 각 리소스 별 소요된 Service time과 각 리소스에서 대기하고 있는 Queuing time의 합으로 구성된다. 
> Tier 별 구분 시 Client, Network, Web, WAS, DB 시간 등으로 나타낼 수 있다.  
> 
> 응답시간 종류  
> 평균 응답시간 (Avg) : 각 Transaction 별 Response의 평균 응답시간  
> 
> 최소 응답시간 (Min) : 각 Transaction 별 Response 중 가장 짧은 응답시간
> 
> 최대 응답시간 (Max) : 각 Transaction 별 Response 중 가장 긴 응답시간  
> 
> 백분율 응답시간 (50th, 60th, 70th, 80th, 90th ...) : 각 Transaction 별 응답시간을 작은 값에서 가장 큰 값으로 늘어 놓았을 때 각 백분율 순위에 위치하는 응답시간  
> 주로, 시스템 및 기타 여러 가지 원인으로 인해 순간적으로 왜곡된 10%의 응답시간을 제외한 90th 응답시간과 평균 응답시간을 가장 의미있는 응답시간으로 인정  
> 
> 처리량과 응답시간의 상관 관계  
> 부하가 증가할 수록 (사용자의 요청이 증가할 수록) 어느 수준까지는 처리량이 선형적으로 증가한다. 왜냐하면 서비스 시간이 일정하기 때문이다. 
> 즉, Little's law에 의해 Response time이 일정한 상태에서 Active user 수가 증가하므로 TPS가 커지게 되는 결과이다.  
> 그러나, 부하가 계속 증가하더라도 어느 시점에 이르러 처리량이 더이상 증가하지 않고 일정한 수준을 유지하게 되는데, 
> 이렇게 되는 변곡점을 포화점/임계점 (Saturation point)이라 부른다. 
> 포화점 이후부터는 대기시간 (Queuing time)이 길어지기 때문에 응답시간이 기하급수적으로 증가하게 되며, 사용자가 증가하더라도 성능이 더 이상 올라가지 않기 때문에 
> 이 때의 동시 사용자 수를 최대 허용 동시 사용자라고 표현한다. Saturation point는 해당 시스템의 최대 처리량을 나타내는 지점이 된다.  
> 성능 테스트의 한 형태인 Critical Performance Test (임계 성능 테스트)의 경우, Saturation point를 찾아내는 것을 목표로 한다. 
> 즉, 해당 시스템의 한계 성능을 확인하기 위함이다. 이로 인해, 최대 TPS와 그 때의 응답시간과 자원사용률, 최대 허용 동시 사용자 수 등을 알 수 있게 된다.  

### 참조사이트
> [TPS와 응답시간](https://performance.tistory.com/4)

---

## HTTP/2
### HTTP/2의 주요 특징과 개선된 기능
> **성능**  
> HTTP/2는 기존의 HTTP/1.x 프로토콜의 모든 핵심 개념들을 그대로 유지하면서 큰 성능 개선을 보여줍니다. 
> 그래서 지금 서비스 중인 웹서비스가 HTTP/1.1로 통신되고 있다면 HTTP/2에 필요한 옵션과 기능들을 추가하는 것 만으로 많은 성능 개선을 볼 수 있습니다.
> 
> **이진 프레이밍 (Binary Framing)**  
> HTTP/2는 이전의 텍스트 기반 프로토콜인 HTTP/1.1 대신 이진 프레임으로 데이터를 전송합니다. 이진 프레임은 효율적인 데이터 전송을 가능하게 합니다.
> 
> **헤더 압축 (Header Compression)**  
> HTTP/2는 헤더 필드를 압축하여 불필요한 데이터 전송을 줄입니다. 이전의 HTTP/1.1은 매 요청마다 중복되는 헤더 필드를 반복적으로 전송해야 했습니다. 
> 하지만 HTTP/2에서는 헤더 필드를 인덱싱하고 압축하여 효율적인 전송을 가능케 합니다. 
>
> **서버 푸시 (Server Push)**  
> HTTP/2는 서버가 클라이언트의 요청에 대해 추가적인 리소스를 미리 전송할 수 있는 기능을 제공합니다. 
> 예를 들어, 클라이언트가 HTML 페이지를 요청하면 서버는 관련된 스타일 시트나 자바스크립트 파일을 미리 보내어 클라이언트의 대기 시간을 줄일 수 있습니다.
> 
> **스트림 (Stream)**   
> HTTP/2는 여러 개의 메시지를 하나의 TCP 연결에서 동시에 처리할 수 있도록 스트림을 도입했습니다. 
> 각각의 스트림은 독립적으로 전송되며, 순서대로 수신되지 않더라도 재조립이 가능합니다. 이를 통해 동시에 여러 개의 요청과 응답을 처리할 수 있어 더 효율적인 통신을 가능하게 합니다.
> 
> HTTP/2는 이러한 기능들을 통해 웹 페이지의 로딩 시간을 단축시키고, 네트워크 대역폭을 효율적으로 사용할 수 있도록 합니다. 
> 그러나 HTTP/2를 사용하려면 웹 서버와 클라이언트가 모두 HTTP/2를 지원해야 합니다. 일반적으로 최신 브라우저와 웹 서버는 HTTP/2를 지원하고 있습니다.  

### Spring HTTP/2 지원
> TODO  

---

## TLS/SSL/HTTPS
### SSL
> Secure Socket Layer  
> SSL은 웹사이트와 브라우저(혹은, 두 서버) 사이에 전송된 데이터를 암호화하여 인터넷 연결 보안을 유지하는 표준 기술입니다.
> 이는 해커가 개인 정보 및 금융 정보를 포함한 전송되는 모든 정보를 열람하거나 훔치는 것을 방지합니다.  
> 
> 네트워크 통신을 할 때 보안을 제공하기 위해 설계된 암호 규약이에요. TCP/IP 네트워크를 사용하는 통신에 적용됩니다.  

### TLS
> Transport Layer Socket  
> 처음에 네스케이프에 의해 발명된 SSL이 표준화가 되며 바뀐 이름이 TLS랍니다. TLS 1.0은 SSL 3.0을 계승했답니다.  

### HTTPS
> 먼저, HTTP 는 다음과 같이 암호화 되지 않은 평문으로 데이터를 전송해요.
> 따라서 누군가 패킷을 훔쳐보는 스니핑(Sniffing) 공격에 취약하죠. 
> HTTP 통신에선 Wire Shark를 통해 패킷을 확인하면 내 주민번호가 그대로 서버로 전송되는 것을 볼 수 있답니다? 
> 때문에, 서버와 클라이언트 간 데이터를 보호하기 위해선 인증서를 통해 패킷을 암호화 한 뒤 전송해야 해요.  
> 이때 사용하는 것이 바로 HTTPS 입니다. HTTPS 가 사용하는 보안 인증(암호화 + 서버인증 등)이 TLS(SSL)입니다. 
> 즉, HTTPS는 TLS 프로토콜 위에서 돌아가는 HTTP 프로토콜입니다.  

### 암호화
> TLS는 보안과 성능상 이슈로 두 가지의 암호화 방법을 혼용해서 사용합니다.
> 1. 대칭키 암호화(Symmetric key algorithm)
> 2. 비대칭키 암호화(Asymmetric key algorithm)
> 
> **대칭키 암호화**  
> 대칭키 암호화란, 암호화를 하는 키와 복호화를 하는 키가 동일한 방식입니다. 이때 암호화와 복호화에 동시에 사용되는 이 키를 대칭키라고 해요.  
> 
> **비대칭키 암호화**  
> 하나의 키를 갖는 대칭키 암호화 방식과 달리, 비대칭키 암호화 방식 은 한 쌍의 키를 갖게 됩니다. 한마디로 비대칭키 암호화 방식에선 키가 2개 입니다.
> 이 두개의 키로 각각 암호화, 복호화를 할 수 있습니다.  
> 만일 A, B라는 두 개의 키가 있다면 A키로 암호화한 데이터는 B키로만 복호화를 할 수 있습니다. 또한 B키로 암호화한 데이터는 A키로만 복호화를 할 수 있습니다.
> A키로 암호화한 데이터를 A키로 복호화 할 순 없으며, B키도 마찬가지 입니다.  
>
> 통상적으로 비대칭키 방식에서 가지는 두개의 키에서 하나는 `공개 키(Public Key)`, 하나는 `개인키(비밀키, Private Key)`라고 부릅니다.  
> 공개키로 암호화 하면 개인키로 복호화 할 수 있고, 개인키로 암호화 하면 공개키로 복호화 할 수 있습니다.
> 이렇듯 한 쌍의 키로 암호화, 복호화를 하는 방식을 `RSA 알고리즘`이라 합니다.  

### TLS 가 제공하는 이점들
> 1. 기밀성: 서버와 주고 받는 데이터가 스니핑 되는 것을 방지합니다.
> 2. 데이터 무결성: 통신 도중 데이터가 제 3자에 의해 악의로 변경될 일이 없습니다.

### 인증서
> 만약 위의 암호화 방식으로만 서버와 클라이언트가 통신을 한다고 가정해보아요.
> 근데 만약 서버가 신뢰할 수 없는 서버라면요..!?
> 요즘 보이스피싱 많이 당하잖아요. 보이스피싱범들이 웹사이트를 실제 검찰 사이트와 똑같이 만들어두고 주민번호로 뭐 조회하라 해요.
> 여기서 내가 주민번호를 치면 보이스피싱범들이 만들어 놓은 서버에 내 주민번호를 보내는 겁니다.
> 이처럼 내가 데이터를 서버에 아무리 암호화 하여 보낸다 한들, 서버가 가짜로 만들어 놓은 쓰레기통 서버라면 큰 문제가 되겠죠?  
> 이처럼, 서버와 클라이언트 간 통신을 할 때는 서버가 신뢰할 수 있는 서버라는 것을 확인하는 작업이 필요해요.
> 이럴 때 사용하는 것이 바로 `인증서` 입니다.  
> 
> 인증서에는 다음과 같은 정보들을 포함하고 있습니다.
> 1. 서비스 정보(인증서를 발급한 CA, 서비스의 도메인 등)
> 2. 서버 측 공개키(공개키, 공개키 암호화 방법)
> 3. 지문, 디지털 서명 등
> 
> **CA (Certificate Authority)**  
> CA 는 인증서를 발급해주는 기관으로, Root Certificate라고 부르기도 합니다.
> CA는 아무 기업이나 할 수 있는 게 아니라 신뢰성이 엄격하게 공인된 기업들만 할 수 있습니다.
> TLS 통신을 하려면 이 CA를 통해서 인증서를 발급받아야 합니다.  
> 
> 미리 알아둘 것은 CA는 자체적으로 공개키와 비밀키를 가지고 있습니다.
> CA의 비밀키는 절대 누설 되어선 안 되며, 실제 어떤 CA 기관은 이 비밀키가 누설되어 파산한 기관도 있습니다.
> 
> **발급 과정**  
> 발급 받고자 하는 기관은 자신의 사이트 정보(도메인 등)과 공개키를 CA에게 제출합니다.
> 그러면 CA는 검증을 걸친 후 발급 받고자 하는 기관의 공개 키를 해시(SHA-256 등) 합니다.
> 이렇게 해시한 값을 `Finger Print(지문)` 이라고 합니다. 
> 
> 이제 이 지문을 CA의 비밀키로 암호화 하고, 인증서의 발급자 서명으로 등록합니다. 이렇게 서명된 것을 `디지털 서명 (Digital Signing)` 이라고 합니다.  
> 이제 CA는 서버에게 이 디지털 서명, 발급자 정보 등등이 등록되어 있는 인증서를 발급해 줍니다.  
> 상위 인증 기관이 하위 인증서가 포함하고 있는 공개키(인증서)를 상위 기관의 비밀키로 암호화 하여 상호 보증하게 되는 것을 `인증서 체인(Certificate Chain)` 이라고 합니다.  

### 인증서 파일 포맷
> **.pem**    
> PEM (Privacy Enhanced Mail)은 Base64 인코딩된 ASCII 텍스트 이다. 파일 구분 확장자로 .pem 을 주로 사용한다.  
> 노트패드에서 열기/수정도 가능하다. 개인키, 서버인증서, 루트인증서, 체인인증서 및 SSL 발급 요청시 생성하는 CSR 등에 사용되는 포맷이며, 
> 가장 광범위하고 거의 99% 대부분의 시스템에 호환되는 산업 표준 포맷이다. (대부분 텍스트 파일)  
>
> **.csr**  
> Certificate Signing Request 의 약자이며 거의 대부분 PEM 포맷이다.
> SSL 발급 신청을 위해서 본 파일 내용을 인증기관 CA 에 제출하는 요청서 파일임을 구분하기 위해서 붙이는 확장자 이다. (대부분 텍스트 파일)
>
> **.crt**  
> 거의 대부분 PEM 포맷이며, 주로 유닉스/리눅스 기반 시스템에서 인증서 파일임을 구분하기 위해서 사용되는 확장자이다. 
> 다른 확장자로 .cer 도 사용된다. 파일을 노트패드 등으로 바로 열어 보면 PEM 포맷인지 바이너리 포맷인지 알수 있지만 99% 는 Base64 PEM 포맷이라고 봐도 무방하다.(대부분 텍스트 파일)
>
> **.cer**  
거의 대부분 PEM 포맷이며, 주로 Windows 기반에서 인증서 파일임을 구분하기 위해서 사용되는 확장자 이다. crt 확장자와 거의 동일한 의미이며, 
> cer 이나 crt 확장자 모두 윈도우에서는 기본 인식되는 확장자이다. 저장할때 어떤 포맷으로 했는지에 따라 다르며, 이름 붙이기 나름이다.  
>
> **.der**  
> Distinguished Encoding Representation (DER) 의 약자이며, 바이너리 포맷이다. 
> 노트패드등으로 열어 봐서는 알아 볼수 없다. 바이너리 인코딩 포맷을 읽을수 있는 인증서 라이브러리를 통해서만 내용 확인이 가능하다.  
> 사설 또는 금융 등 특수 분야 및 아주 오래된 구형 시스템을 제외하고는, 최근 웹서버 SSL 작동 시스템 에서는 흔히 사용되는 포맷은 아니다. (바이너리 이진 파일)
> 
> **.pfx / .p12**  
> PKCS#12 바이너리 포맷이며, Personal Information Exchange Format 를 의미한다. 주로 
> Windows IIS 기반에서 인증서 적용/이동시 활용된다. 주요 장점으로는 개인키, 서버인증서, 루트인증서, 체인인증서를 모두 담을수 있어서 SSL 인증서 적용이나 
> 또는 이전시 상당히 유용하고 편리하다. Tomcat 등 요즘에는 pfx 설정을 지원하는 서버가 많아지고 있다.(바이너리 이진 파일)  
>  
> **.key**  
> 주로 openssl 및 java 에서 개인키 파일임을 구분하기 위해서 사용되는 확장자이다. PEM 포맷일수도 있고 DER 바이너리 포맷일수도 있으며, 
> 파일을 열어봐야 어떤 포맷인지 알수가 있다. 저장할때 어떤 포맷으로 했는지에 따라 다르며, 확장자는 이름 붙이기 나름이다.  
> 
> **.jks**  
> Java Key Store 의 약자이며, Java 기반의 독자 인증서 바이너리 포맷이다. 
> pfx 와 마찮가지로 개인키, 서버인증서, 루트인증서, 체인인증서를 모두 담을수 있어서 SSL 인증서 파일 관리시 유용하다. 
> Tomcat 에서 SSL 적용시 가장 많이 사용되는 포맷이다. (바이너리 이진 파일)  

### 참조사이트
> [TLS(SSL) - 1. TLS의 암호화 방식(대칭키, 비대칭키)](https://babbab2.tistory.com/4?category=1058182)  
> [TLS(SSL) - 2. 인증서, CA, SSL 인증서를 통해 서버를 인증하는 방법](https://babbab2.tistory.com/5?category=1058182)  
> [SSL 인증서 파일 포맷 및 용어설명](https://exhibitlove.tistory.com/28)

---

## 외부 API 장애 대응
### 타임 아웃
> 오래 대기하는 것보다 빨리 에어를 발생시키는 것이 성능상 나음: 동시에 대기하는 외부 연동 개수가 많아질수록 내 서비스는 점점 먹통/느려짐
> 
> 외부 API 호출 시 두 개의 타임아웃 설정
> * 연결 시간 타임 아웃: 보통 1~5초 이내로 설정
> * 응답 시간 타임 아웃: 보통 1~3초 사이가 적당, 외부 서비스 특징에 따라 길게 주기도 함(ex: 결제 승인은 30초)
> 
> HTTP 커넥션 풀 사용 시 추가 타임 아웃 설정 가능.  
> 풀이 모두 사용중인 경우에 풀에서 커넥션 구할 때 대기하는 최대 시간: 보통 1~5초 이내로 설정 혹은 상황에 따라 바로 에러를 내는 경우도 존재함.  

### 벌크헤드
> 외부 서비스를 많이 사용하는 경우에 HTTP 커넥션 풀을 1개로 공동으로 사용하게 되면 하나의 외부 서비스가 느려져서 커넥션 반납 시간이 증가하면 다른 외부 서비스에도
> 영향이 가게됨.
> 그래서 외부 서비스가 하나의 커넥션 풀을 공동으로 사용하는 것이 아닌 각각의 외부 서비스마다 HTTP 커넥션 풀을 따로 둬서 사용하게 되면
> 하나의 서비스와 연동이 느려져도 다른 서비스 연동은 영향이 감소함.  

### 서킷브레이커
> 외부 시스템 장애 지속 시 계속되는 타임아웃/50x 응답에 따른 서비스 에러가 발생하는 상태이며, 외부 서비스가 비정상임에도 계속해서 요청을 보내기 때문에 
> 내 시스템의 전체적인 응답 시간이 느려지고 처리량이 감소하게 됨.  
> 
> 연동 코드와 외부 서비스 사이에 서킷 브레이커를 둬서 외부 서비스의 오류가 지속되는 경우 서킷 브레이커가 일정 시간동안 외부 서비스 호출을 차단함.  
> 서킷 브레이커가 외부 서비스 호출을 하지 않고 바로 에러를 응답해버려서 빠른 실패(fail fast)가 가능해진다 -> 외부 서비스 장애에 따른 응답 시간 증가가 일어나지 않게됨.
> 
> Circuit breaker 패턴은 Release It에서 처음 소개된 패턴이고, 전기의 회로차단기에서 차용한 개념입니다. 
> 회로가 close될때는 정상적으로 전기가 흐르다가 문제가 생기면 회로를 open하여 더이상 전기가 흐르지 않도록 한 것과 같이, 
> 평소(Close state)에는 정상적으로 동작하다가, 오류 발생시(Open state) 더이상 동작하지 않도록 합니다. 
> 이렇게 문제가 되는 기능 자체를 동작하지 않게 해서 리소스를 점유하지 않게 하는 겁니다.
> 
> **Circuit Breaker의 3가지 상태**
> * Closed: 모든 것이 정상인 상태
> * Open: 외부에 장애가 발생한 상황
> * Half Open: Open 상태가 되고 일정 시간이 지난 상황, 일부 허용된 요청들이 성공할 경우 Closed 상태로 전환. 여기서 외부 장애가 발생했다고 판단하는 기준은 크게 2가지로 나뉜다.
> 1.기준 시간보다 오래 걸린 요청(timeout), 2.실패하거나 오류를 응답받은 요청
> 이 2가지 장애 상황에 대해서 특정 기준을 적용하여 규칙을 만들어 서킷 브레이커 패턴을 동작한다.  
> 특정 요청이 3번 연속 실패 시, Open상태로 변경  
> 특정 요청이 3번 연속, 5초 이상 시간 초과 할 경우 Open상태로 변경  
> Open상태로 바꿨던 요청이 3번 이상 성공할 경우 다시 Closed  
> 
> **장애 대안**  
> 장애 발생 시, 원하는 응답이나 데이터를 얻지 못한다. 이때 아무런 대응책이 없다면 클라이언트 서비스 역시 장애가 발생하게 된다. 
> 서킷 브레이커를 적용한다면 자체적으로 캐싱해 둔 값으로 응답하는 등 장애에 대한 대안을 커스터마이징 할 수 있다.  
> 
> **Spring 의 서킷 브레이커 라이브러리**
> * Hystrix : 넷플릭스에서 만든 오픈소스, 그러나 현재는 유지보수가 더이상되지 않아 사용권장 하지 않음 2018년에 넷플릭스가 더 이상 개발하지 않는다고 발표.
> * Resilience4j : 함수형 프로그래밍으로 설계된 경량 장애 허용 라이브러리로 서킷브레이커 패턴을 위해 사용  

### 참조사이트
> [외부 API 장애에 영향 덜 받는 3가지 방법](https://www.youtube.com/watch?v=nuRO0ZBFdKk)
> [[프로그래밍 패턴] Circuit Breaker 패턴](https://velog.io/@vies00/Circuit-Breaker-Pattern)  
> [서킷 브레이커[CirCuit Breaker] 패턴이란?](https://diddl.tistory.com/181)

---

## OAuth 2.0
### 특징
> TODO

---

## GraphQL
### 특징
> TODO

---

## gRPC
### TODO
> TODO
